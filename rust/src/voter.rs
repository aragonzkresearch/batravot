use ark_ec::group::Group;
use ark_ec::ProjectiveCurve;
use ark_ff::{BigInteger256, PrimeField};
use ark_std::UniformRand;
use crate::{ElectionSpecifiers, G1, G2, ScalarField};
use rand::rngs::ThreadRng;


/**
 * A voter is a struct that contains the private and public keys of a voter.
 * The private key is a scalar field element, and the public key is a point on the G1 curve.
 */
pub struct Voter {
    pub prk: ScalarField,
    pub pbk: G1,
}

impl Voter {
    /**
     * Create a new voter with a random private key and public key
     */
    pub fn new(rng: &mut ThreadRng) -> Self {
        // A random scalar field element
        let prk = ScalarField::rand(rng);
        // prk * G1
        let pbk = G1::prime_subgroup_generator().mul(prk.into_repr());

        Self {
            prk,
            pbk,
        }
    }

    /**
     * Generate a ballot for a given election
     */
    pub fn generate_ballot(&self, election_id: BigInteger256, vote: Vote, specifiers: &ElectionSpecifiers) -> Ballot {

        // We first need to check that the specifiers we have obtained from online are correct
        specifiers.check_specifiers(election_id);

        // Choose correct specifier based on vote
        let specifier = match vote {
            Vote::Yes => &specifiers.yes.0,
            Vote::No => &specifiers.no.0,
        };

        // Generate a vote proof
        // [specifiers in G1] * prk
        let vote_proof = specifier.mul(&self.prk);

        // Generate a ballot
        let ballot = Ballot {
            vote,
            vote_proof,
            pbk: self.pbk.clone()
        };

        ballot
    }
}

impl Voter {

}


/**
 * A vote is a choice of either yes or no.
 */
#[derive(Debug, PartialEq)]
pub enum Vote {
    Yes,
    No,
}

/**
 * A ballot is generated by the voter and contains:
 * 1. The vote
 * 2. A proof that the vote is valid
 * 3. Voter public key
 */
#[derive(Debug)]
pub struct Ballot {
    pub vote: Vote,
    pub vote_proof: G1,
    pub pbk: G1,
}

